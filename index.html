<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title>Ford Model T – Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Tailwind via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel (so JSX in the browser works) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-amber-50">
    <div id="root"></div>

    <!-- IMPORTANT: tell Babel to use the React preset -->
    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useCallback, useRef } = React;

      const CLAMP = (v, min, max) => Math.min(Math.max(v, min), max);

      // --- Definicja segmentów trasy (długość px, krzywizna -1..1) ---
      const TRACK_SEGMENTS = [
        { len: 400, k: 0.0 },
        { len: 700, k: 0.6 },
        { len: 300, k: 0.0 },
        { len: 600, k: -0.55 },
        { len: 500, k: 0.25 },
        { len: 800, k: -0.35 },
        { len: 400, k: 0.0 },
      ];
      const TRACK_TOTAL_LEN = TRACK_SEGMENTS.reduce((a, s) => a + s.len, 0);

      function curvatureAt(z) {
        let zz = ((z % TRACK_TOTAL_LEN) + TRACK_TOTAL_LEN) % TRACK_TOTAL_LEN;
        for (let i = 0; i < TRACK_SEGMENTS.length; i++) {
          const s = TRACK_SEGMENTS[i];
          if (zz <= s.len) {
            const t = s.len === 0 ? 0 : zz / s.len;
            const ease = t * t * (3 - 2 * t); // ease-in-out dla gładkości
            return s.k * ease;
          }
          zz -= s.len;
        }
        return 0;
      }

      function CarCockpitGame() {
        const [steeringAngle, setSteeringAngle] = useState(0); // stopnie -45..45 (kąt kierownicy)
        const [activeKeys, setActiveKeys] = useState(new Set());
        const [touchControl, setTouchControl] = useState(null); // 'left' | 'right' | null

        // Stan pojazdu względem osi drogi
        const [carX, setCarX] = useState(0); // px – przesunięcie boczne
        const carVelRef = useRef(0); // px/s – prędkość boczna
        const headingRef = useRef(0); // rad – kąt auta względem osi drogi (0 = równolegle)

        // Ruch do przodu (scroll drogi)
        const speedRef = useRef(120); // px/s – optyczna prędkość do przewijania
        const zRef = useRef(0); // odległość wzdłuż trasy (px)

        // Runtime
        const lastTsRef = useRef(null);
        const jitterRef = useRef(0); // drżenie od off-road/lat-g

        // --- Sterowanie ---
        const updateSteering = useCallback(() => {
          const isLeftActive = activeKeys.has("ArrowLeft") || activeKeys.has("a") || touchControl === "left";
          const isRightActive = activeKeys.has("ArrowRight") || activeKeys.has("d") || touchControl === "right";

          // Maksymalna prędkość obrotu kierownicy (deg per frame update call)
          const TURN_SPEED = 3.6; // im większe, tym "szybsze nadążanie" rąk

          if (isLeftActive && !isRightActive) {
            setSteeringAngle((prev) => Math.max(prev - TURN_SPEED, -45));
          } else if (isRightActive && !isLeftActive) {
            setSteeringAngle((prev) => Math.min(prev + TURN_SPEED, 45));
          } else {
            // Sprężyna – tłumienie proporcjonalne (realistyczniejszy powrót)
            setSteeringAngle((prev) => (Math.abs(prev) < 0.2 ? 0 : prev * 0.92));
          }
        }, [activeKeys, touchControl]);

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (["ArrowLeft", "ArrowRight", "a", "d", "A", "D"].includes(e.key)) {
              e.preventDefault();
              const k = e.key.toLowerCase();
              setActiveKeys((prev) => new Set(prev).add(k === "a" || k === "d" ? k : e.key));
            }
          };
          const handleKeyUp = (e) => {
            if (["ArrowLeft", "ArrowRight", "a", "d", "A", "D"].includes(e.key)) {
              e.preventDefault();
              const k = e.key.toLowerCase();
              setActiveKeys((prev) => {
                const ns = new Set(prev);
                ns.delete(k === "a" || k === "d" ? k : e.key);
                return ns;
              });
            }
          };
          window.addEventListener("keydown", handleKeyDown);
          window.addEventListener("keyup", handleKeyUp);
          return () => {
            window.removeEventListener("keydown", handleKeyDown);
            window.removeEventListener("keyup", handleKeyUp);
          };
        }, []);

        // --- Pętla rAF (fizyka + przewijanie) ---
        useEffect(() => {
          let raf;
          const loop = (ts) => {
            if (lastTsRef.current == null) lastTsRef.current = ts;
            const dt = Math.min(0.05, (ts - lastTsRef.current) / 1000);
            lastTsRef.current = ts;

            updateSteering();

            const speed = speedRef.current; // optyczna prędkość do przeliczeń
            const kRoad = curvatureAt(zRef.current); // krzywizna drogi tu i teraz (-1..1)

            // --- Model skrętu (prosty bicycle) ---
            const steerNorm = CLAMP(steeringAngle / 45, -1, 1);
            const wheelAngle = steerNorm * (Math.PI / 9); // ~20° na kołach (bardziej realistycznie)

            // Yaw rate ≈ (v / L) * tan(δ). L traktujemy jako stałą skalującą.
            const L = 180; // "rozstaw osi" w pikselach w world-space (skala arbitralna)
            const yawRate = (speed / L) * Math.tan(wheelAngle);

            // Droga "wymusza" skręt (jadąc idealnie po osi bez skrętu, krzywa droga obraca układ odniesienia)
            const roadPull = kRoad * speed * 0.0009; // współczynnik dobrany eksperymentalnie

            // Inercja kierunku jazdy (headinng), z łagodnym tłumieniem
            headingRef.current += (yawRate - roadPull) * dt;
            headingRef.current *= 0.999; // drobne tłumienie drgań

            // --- Lateralna dynamika ---
            const latFromHeading = Math.sin(headingRef.current) * speed * 0.6; // projekcja prędkości na oś X
            const centering = -carX * 0.8; // łagodny powrót do osi (banking/wybrzuszenie jezdni)
            const offroad = Math.abs(carX) > 190; // powyżej ~190px uznajemy, że to pobocze
            const grip = offroad ? 0.45 : 1.0; // mniejsza przyczepność na poboczu

            const targetLatVel = (latFromHeading + centering) * grip;
            const accel = (targetLatVel - carVelRef.current) * (offroad ? 3.0 : 6.0); // tłumienie do celu
            carVelRef.current += accel * dt;
            setCarX((x) => CLAMP(x + carVelRef.current * dt, -240, 240));

            // Drżenie kamery zależne od przeciążenia bocznego i off-road
            const latG = Math.abs(carVelRef.current) * 0.004 + (offroad ? 0.7 : 0);
            jitterRef.current = jitterRef.current * 0.9 + latG * 0.1;

            // Lekkie ograniczenie prędkości w ostrych zakrętach (optyczne)
            const maxCornerSpeed = 180 / (1 + Math.abs(kRoad) * 4);
            const speedTarget = Math.max(90, maxCornerSpeed);
            speedRef.current += (speedTarget - speedRef.current) * dt * 0.6;

            // Przewijanie trasy do przodu
            zRef.current += speedRef.current * dt;

            raf = requestAnimationFrame(loop);
          };
          raf = requestAnimationFrame(loop);
          return () => cancelAnimationFrame(raf);
        }, [steeringAngle, updateSteering]);

        // Touch helpers
        const handleTouchStart = (dir) => setTouchControl(dir);
        const handleTouchEnd = () => setTouchControl(null);

        const wheelAngle = steeringAngle; // dla UI kierownicy (stopnie)

        // Subtelny jitter wizualny (kokpit)
        const jitter = jitterRef.current;
        const cockpitShake = `translateX(${(Math.random() - 0.5) * jitter * 2}px)`;

        return (
          <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-amber-100 via-yellow-50 to-green-100 p-4">
            <h1 className="text-4xl font-bold text-amber-900 mb-6 text-center drop-shadow-md font-serif">
              🚗 Ford Model T – 1930 🚗
            </h1>

            {/* Kokpit */}
            <div
              className="relative w-full max-w-5xl h-[560px] rounded-2xl overflow-hidden shadow-2xl border-8 border-amber-900"
              style={{ background: "linear-gradient(to bottom, #8B4513, #A0522D, #654321)", transform: cockpitShake }}
            >
              {/* Szyba z drogą */}
              <div className="absolute top-0 w-full h-64 rounded-t-2xl overflow-hidden border-b-4 border-amber-800 bg-gradient-to-b from-yellow-100 via-amber-50 to-green-100">
                <RoadWindow zRef={zRef} carX={carX} />
              </div>

              {/* Deska rozdzielcza */}
              <div
                className="absolute bottom-0 w-full h-52 rounded-b-2xl"
                style={{ background: "radial-gradient(ellipse at center, #8B4513 0%, #654321 50%, #3E2723 100%)" }}
              >
                <div
                  className="absolute inset-0 opacity-30"
                  style={{
                    background:
                      "repeating-linear-gradient(90deg, transparent 0px, rgba(139,69,19,0.3) 2px, transparent 4px)",
                    mixBlendMode: "multiply",
                  }}
                />

                {/* Zegar stylizowany */}
                <div className="absolute left-12 top-6 w-28 h-28 rounded-full border-8 shadow-2xl" style={{ borderColor: "#B8860B", background: "radial-gradient(circle, #FFFDD0 0%, #F5F5DC 100%)" }}>
                  <div className="absolute inset-0 text-xs font-serif text-amber-900">
                    <div className="absolute top-1 left-1/2 -translate-x-1/2 font-bold">60</div>
                    <div className="absolute right-2 top-1/2 -translate-y-1/2 font-bold">40</div>
                    <div className="absolute bottom-1 left-1/2 -translate-x-1/2 font-bold">0</div>
                    <div className="absolute left-2 top-1/2 -translate-y-1/2 font-bold">20</div>
                  </div>
                  <div className="absolute top-1/2 left-1/2 w-0.5 h-10 bg-black origin-bottom" style={{ transform: "translate(-50%, -100%) rotate(0deg)" }} />
                  <div className="absolute top-1/2 left-1/2 w-3 h-3 rounded-full" style={{ backgroundColor: "#B8860B", transform: "translate(-50%, -50%)" }} />
                </div>

                {/* Środkowe kontrolki */}
                <div className="absolute left-1/2 -translate-x-1/2 top-8 flex space-x-6">
                  {["CHOKE", "SPARK", "SPEED"].map((label) => (
                    <div key={label} className="flex flex-col items-center">
                      <div className="w-4 h-16 rounded-full border-2 border-amber-800" style={{ background: "linear-gradient(to bottom, #B8860B, #DAA520)" }} />
                      <div className="text-xs text-amber-100 font-serif mt-1">{label}</div>
                    </div>
                  ))}
                </div>

                {/* Dźwignia biegów */}
                <div className="absolute right-16 bottom-8 w-12 h-24 rounded-t-full border-4 border-amber-700 shadow-lg bg-gradient-to-b from-amber-800 to-amber-900">
                  <div className="w-full h-full p-2 flex flex-col items-center justify-end">
                    <div className="w-6 h-6 rounded-full border-2 border-yellow-600 mb-2" style={{ backgroundColor: "#B8860B" }} />
                    <div className="text-xs text-amber-100 font-serif">GEAR</div>
                  </div>
                </div>

                {/* Pedały */}
                <div className="absolute bottom-2 left-1/3 flex space-x-4">
                  {[0, 1, 2].map((i) => (
                    <div key={i} className="w-8 h-4 rounded border border-amber-800" style={{ background: "linear-gradient(to bottom, #B8860B, #8B4513)" }} />
                  ))}
                </div>
              </div>

              {/* Kierownica */}
              <div
                className="absolute top-28 left-1/2 z-10 transition-transform duration-100 ease-out"
                style={{ transform: `translateX(-50%) rotate(${wheelAngle}deg)` }}
              >
                <div className="w-48 h-48 border-8 rounded-full relative shadow-2xl" style={{ borderColor: "#2F1B14", background: "conic-gradient(from 0deg, #8B4513, #A0522D, #8B4513)" }}>
                  <div className="absolute inset-8 rounded-full" />
                  <div className="absolute top-1/2 left-1/2 w-1 h-32 bg-gradient-to-b from-amber-800 to-amber-900 -translate-x-1/2 -translate-y-1/2 rounded-full shadow-lg" />
                  <div className="absolute top-1/2 left-1/2 w-32 h-1 bg-gradient-to-r from-amber-800 to-amber-900 -translate-x-1/2 -translate-y-1/2 rounded-full shadow-lg" />
                  <div className="absolute top-1/2 left-1/2 w-16 h-16 rounded-full border-4 border-amber-800 shadow-inner flex items-center justify-center" style={{ background: "radial-gradient(circle, #DAA520 0%, #B8860B 70%, #8B4513 100%)", transform: "translate(-50%, -50%)" }}>
                    <div className="text-amber-900 text-lg font-bold font-serif">F</div>
                  </div>
                </div>
              </div>

              {/* Ręce – zawsze na kierownicy */}
              <Hands wheelAngle={wheelAngle} />

              {/* Maska/przód auta – offset zgodny z pozycją auta */}
              <div
                className="absolute bottom-28 left-1/2 z-0 transition-transform duration-100 ease-out"
                style={{ transform: `translateX(calc(-50% + ${carX}px))` }}
              >
                <CarHood />
              </div>
            </div>

            {/* Sterowanie dotykowe */}
            <div className="flex justify-center gap-8 mt-6">
              {["left", "right"].map((dir) => (
                <button
                  key={dir}
                  className={`w-20 h-20 rounded-full border-4 font-bold text-2xl shadow-lg transition-all duration-100 select-none font-serif ${
                    touchControl === dir || activeKeys.has(dir === "left" ? "ArrowLeft" : "ArrowRight") ||
                    activeKeys.has(dir === "left" ? "a" : "d")
                      ? "border-amber-800 text-white scale-95 shadow-inner"
                      : "border-amber-600 text-amber-800 hover:bg-amber-50"
                  }`}
                  style={{
                    backgroundColor:
                      touchControl === dir || activeKeys.has(dir === "left" ? "ArrowLeft" : "ArrowRight") ||
                      activeKeys.has(dir === "left" ? "a" : "d")
                        ? "#8B4513"
                        : "#F5F5DC",
                    borderColor: "#8B4513",
                  }}
                  onTouchStart={(e) => {
                    e.preventDefault();
                    handleTouchStart(dir);
                  }}
                  onTouchEnd={(e) => {
                    e.preventDefault();
                    handleTouchEnd();
                  }}
                  onMouseDown={() => handleTouchStart(dir)}
                  onMouseUp={() => handleTouchEnd()}
                  onMouseLeave={() => handleTouchEnd()}
                >
                  {dir === "left" ? "←" : "→"}
                </button>
              ))}
            </div>

            {/* Panel info */}
            <div className="mt-6 text-center bg-amber-50 bg-opacity-95 p-6 rounded-xl shadow-lg max-w-md border-4 border-amber-800">
              <p className="text-xl font-bold text-amber-900 mb-3 font-serif">🎩 Ford Model T Simulator – 1930 🎩</p>
              <div className="space-y-2 text-sm text-amber-800 font-serif">
                <div className="flex items-center justify-center gap-2">
                  <span className="font-mono bg-amber-200 px-3 py-1 rounded-full border border-amber-400">← → / A D</span>
                  <span>Sterowanie</span>
                </div>
              </div>
              <div className="mt-4 p-3 bg-amber-100 rounded-lg border-2 border-amber-300">
                <p className="text-sm font-bold text-amber-900 font-serif">
                  Kąt kierownicy: <span className="font-mono text-lg">{Math.round(steeringAngle)}°</span>
                </p>
                <p className="text-sm font-bold text-amber-900 font-serif">
                  Pozycja auta: <span className="font-mono text-lg">{Math.round(carX)} px</span>
                </p>
                <p className="text-xs text-amber-700 mt-1 font-serif italic">"Trzymaj się pasa – zakręt wciąga!"</p>
              </div>
            </div>
          </div>
        );
      }

      // ---- Komponent: pseudo-3D okno z drogą i zakrętami ----
      function RoadWindow({ zRef, carX }) {
        const SLICES = 28;
        const H = 256; // wysokość okna drogi (px)
        const horizonY = 24; // górna linia horyzontu
        const roadBaseWidth = 120; // szerokość drogi przy horyzoncie (px)
        const roadBottomWidth = 520; // szerokość przy dole (px)

        const tiles = [];
        let cumulativeOffset = 0; // globalny dryf środka drogi (dla krzywizny)

        // Parallax środka drogi zależny od krzywizny + pozycji auta (auto "ściąga" środek do siebie)
        const k0 = curvatureAt(zRef.current);
        cumulativeOffset += k0 * 80 - carX * 0.15;

        for (let i = 0; i < SLICES; i++) {
          const depth0 = i / SLICES; // 0 (daleko) .. 1 (blisko)
          const depth1 = (i + 1) / SLICES;

          // dynamiczna krzywizna zmienia się w głąb – dodajemy narastający offset
          const kSlice = curvatureAt(zRef.current + i * 40);
          const center0 = cumulativeOffset + kSlice * 140 * depth0;
          const center1 = cumulativeOffset + kSlice * 140 * depth1;

          const w0 = roadBaseWidth + (roadBottomWidth - roadBaseWidth) * depth0;
          const w1 = roadBaseWidth + (roadBottomWidth - roadBaseWidth) * depth1;

          const y0 = horizonY + (H - horizonY) * depth0;
          const y1 = horizonY + (H - horizonY) * depth1;

          const L0 = 0.5 * windowWidth() + center0 - w0 / 2;
          const R0 = 0.5 * windowWidth() + center0 + w0 / 2;
          const L1 = 0.5 * windowWidth() + center1 - w1 / 2;
          const R1 = 0.5 * windowWidth() + center1 + w1 / 2;

          const color = i % 2 === 0 ? "#6f6a63" : "#777169"; // delikatny banding

          tiles.push(
            <div
              key={"road-" + i}
              className="absolute"
              style={{
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                clipPath: `polygon(${L0}px ${y0}px, ${R0}px ${y0}px, ${R1}px ${y1}px, ${L1}px ${y1}px)`,
                background: color,
              }}
            />
          );

          // Pasy krawędziowe
          const shoulder = 8 + 8 * depth0;
          const sL0 = L0 - shoulder;
          const sR0 = R0 + shoulder;
          const sL1 = L1 - shoulder;
          const sR1 = R1 + shoulder;

          tiles.push(
            <div
              key={"shoulder-" + i}
              className="absolute"
              style={{
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                clipPath: `polygon(${sL0}px ${y0}px, ${L0}px ${y0}px, ${L1}px ${y1}px, ${sL1}px ${y1}px, ${sL0}px ${y0}px)`,
                background: "#a78b5a",
              }}
            />
          );
          tiles.push(
            <div
              key={"shoulderR-" + i}
              className="absolute"
              style={{
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                clipPath: `polygon(${R0}px ${y0}px, ${sR0}px ${y0}px, ${sR1}px ${y1}px, ${R1}px ${y1}px, ${R0}px ${y0}px)`,
                background: "#a78b5a",
              }}
            />
          );

          // Linia środkowa (przerywana)
          if (i % 2 === 0) {
            const lw0 = 6 * (0.4 + depth0);
            const lw1 = 6 * (0.4 + depth1);
            const cL0 = 0.5 * (L0 + R0) - lw0 / 2;
            const cR0 = 0.5 * (L0 + R0) + lw0 / 2;
            const cL1 = 0.5 * (L1 + R1) - lw1 / 2;
            const cR1 = 0.5 * (L1 + R1) + lw1 / 2;
            tiles.push(
              <div
                key={"center-" + i}
                className="absolute"
                style={{
                  left: 0,
                  right: 0,
                  top: 0,
                  bottom: 0,
                  clipPath: `polygon(${cL0}px ${y0}px, ${cR0}px ${y0}px, ${cR1}px ${y1}px, ${cL1}px ${y1}px)`,
                  background: "#f2d37a",
                }}
              />
            );
          }
        }

        // Proste drzewka po bokach (parallax)
        const deco = [];
        for (let i = 0; i < 6; i++) {
          const depth = i / 6;
          const y = horizonY + (H - horizonY) * depth + 20;
          const kSlice = curvatureAt(zRef.current + i * 120);
          const center = (k0 * 80 - carX * 0.15) + kSlice * 140 * depth;
          const baseX = 0.5 * windowWidth() + center;
          const offset = 260 + 160 * depth;
          const size = 24 + 46 * depth;
          // lewa
          deco.push(
            <div
              key={"treeL-" + i}
              className="absolute rounded-sm"
              style={{
                width: size,
                height: size,
                background: "linear-gradient(#29502c, #17381a)",
                left: baseX - offset - size / 2,
                top: y - size,
                boxShadow: "0 2px 8px rgba(0,0,0,0.25)",
              }}
            />
          );
          // prawa
          deco.push(
            <div
              key={"treeR-" + i}
              className="absolute rounded-sm"
              style={{
                width: size,
                height: size,
                background: "linear-gradient(#29502c, #17381a)",
                left: baseX + offset - size / 2,
                top: y - size,
                boxShadow: "0 2px 8px rgba(0,0,0,0.25)",
              }}
            />
          );
        }

        return (
          <div className="relative w-full h-full">
            {/* niebo/horyzont */}
            <div className="absolute inset-0 bg-gradient-to-b from-sky-100 via-amber-50 to-green-100" />
            {/* asfalt i pobocza */}
            {tiles}
            {/* dekoracje */}
            {deco}
          </div>
        );
      }

      function windowWidth() {
        if (typeof window === "undefined") return 1024;
        return Math.max(960, Math.min(1400, window.innerWidth));
      }

      // ---- Ręce (SVG) trzymające kierownicę ----
      function Hands({ wheelAngle }) {
        const baseLeft = -60; // pozycja ~10
        const baseRight = 60; // pozycja ~2

        return (
          <div
            className="absolute top-[136px] left-1/2 z-20 pointer-events-none"
            style={{ transform: "translateX(-50%)" }}
          >
            <HandSVG angleDeg={baseLeft + wheelAngle} side="left" />
            <HandSVG angleDeg={baseRight + wheelAngle} side="right" />
          </div>
        );
      }

      function HandSVG({ angleDeg, side }) {
        const R = 96; // promień chwytu względem środka kierownicy
        const rad = (angleDeg * Math.PI) / 180;
        const x = Math.cos(rad) * R;
        const y = Math.sin(rad) * R;
        const handRot = angleDeg + (side === "left" ? -15 : 15);

        return (
          <svg
            viewBox="0 0 140 140"
            className="absolute"
            style={{
              width: 140,
              height: 140,
              left: 70 + x - 70,
              top: 70 + y - 70,
              transform: `rotate(${handRot}deg)`,
            }}
          >
            {/* Przedramię */}
            <rect x="60" y="84" width="20" height="46" rx="10" fill="#EBC8A2" stroke="#D2A57B" />
            {/* Mankiet koszuli */}
            <rect x="58" y="76" width="24" height="10" rx="4" fill="#BFD7FF" stroke="#8CB6E6" />
            {/* Dłoń */}
            <g transform="translate(50,58)">
              <rect x="0" y="8" width="40" height="24" rx="10" fill="#F2D1AE" stroke="#D2A57B" />
              <ellipse cx="6" cy="18" rx="6" ry="10" fill="#F2D1AE" stroke="#D2A57B" />
              {[10, 20, 30].map((px) => (
                <line key={px} x1={px} y1={10} x2={px} y2={30} stroke="#DDB892" strokeWidth={1} />
              ))}
            </g>
          </svg>
        );
      }

      // ---- Wizualizacja maski/przodu auta ----
      function CarHood() {
        return (
          <div className="relative w-[320px] h-[120px]">
            <div
              className="absolute left-1/2 -translate-x-1/2 bottom-0 w-[300px] h-[90px] rounded-t-[40px] border-4 shadow-xl"
              style={{ background: "linear-gradient( to top, #3a2b1f, #5a3c2a )", borderColor: "#2b1a12" }}
            />
            <div className="absolute left-1/2 -translate-x-1/2 bottom-2 w-16 h-16 rounded-md border-4" style={{ background: "#2b1a12", borderColor: "#6b4b2e" }} />
            <div className="absolute left-6 bottom-2 w-10 h-10 rounded-full border-4" style={{ background: "#d4c08a", borderColor: "#6b4b2e" }} />
            <div className="absolute right-6 bottom-2 w-10 h-10 rounded-full border-4" style={{ background: "#d4c08a", borderColor: "#6b4b2e" }} />
          </div>
        );
      }

      // =============================
      //  Render do DOM
      // =============================
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<CarCockpitGame />);
    </script>
  </body>
</html>
